# Tips from problem solving 

- check in the if or while loop do I need to include the  >= or only > 
- create empty array as follows  
```py
[]*lenofdata
```
- Dry run the problem with the inputs 
- Infinity 
```py
temp = float('inf')
```



## For loop 

range(start, stop, step)

- range(len(arr))
- range(3, 6)
- range(3, 20, 2) #

```python
for i in range(n-1, -1, -1):
    print(arr[i])

```

nested loops that starts from the parent loop value 
```python
for i in range(x):
        for j in range(i+1, x):
            for k in range(j+1,x):
                if i < j < k and  nums[i] < nums[j]< nums[k]:
                    print(nums[i]  , nums[j] ,  nums[k]) 
                    return True
```


## join

```python
text = ['Python', 'is', 'a', 'fun', 'programming', 'language']
# join elements of text with space
print(' '.join(text))
```

string split,join
```py
string.split(' ')
' '.join(list_string)
```

## Heapify 
```
# importing "heapq" to implement heap queue
import heapq

# initializing list
li = [5, 7, 9, 1, 3]

# using heapify to convert list into heap
heapq.heapify(li)

# printing created heap
print("The created heap is : ", end="")
print(list(li))

# using heappush() to push elements into heap
# pushes 4
heapq.heappush(li, 4)

# printing modified heap
print("The modified heap after push is : ", end="")
print(list(li))

# using heappop() to pop smallest element
print("The popped and smallest element is : ", end="")
print(heapq.heappop(li))
```

# Pattern 
Post processing : always the prev value should last in the processing 

```py
nums = [1,2,3,4]
n = len(nums)
answer = [1] * n
        
# Step 1: Build prefix products
prefix = 1
for i in range(n):
    answer[i] = prefix
    prefix *= nums[i]  # prefix is the current value but we are storing the answer in the next iteration
#Output
[1, 1, 2, 6]
[]
```
If we just change the order , it will become  current processing 
```py
prefix = 1
for i in range(n):
    prefix *= nums[i]
    answer[i] = prefix # changed the order 

# Output 
[1, 2, 6, 24]
```

# Sliding Window

### Fixed sliding Window template 

```py
left = right = 0
while right < n:
    # If the window has reached the expected fixed length, we slide
    # the window (move both left and right).
    if right - left + 1 == fixed_window_size:
        # Process the current window.
        result = process_current_window()
        left += 1
    right += 1

```
Note: Always following condition should be at the bottom 
```
    left += 1
right += 1
```
### Dynamic Sliding window template 

```py
left = right = 0
while right < n:
    # While the condition is violated, the window is invalid, so

    # shrink the window by advancing the left pointer.
    while condition is violated:
        left += 1

    # Once the window is valid, process it and then expand the window
    # by advancing the right pointer.
    result = process_current_window()
    right += 1

```

